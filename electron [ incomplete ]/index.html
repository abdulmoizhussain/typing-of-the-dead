<!DOCTYPE html>
<html>

<head>
	<style>
		img,
		canvas {
			display: block;
		}
	</style>
</head>

<body>
	<!-- <script async src="opencv.js" onload="onOpenCvReady();" type="text/javascript"></script> -->
	<script type="text/javascript">
		const images = [];
		const cv = require("./opencv.js");
		console.log(cv);
		// console.log(cv.getBuildInformation());

		(async function () {
			const fs = require("fs");
			const srcImgBase64 = fs.readFileSync("./greenbox.png").toString("base64");
			const srcImgElement = await createAndShowImageElement("data:image/png;base64," + srcImgBase64, "src");

			let srcMat = cv.imread(srcImgElement);
			let contoursMat = srcMat.clone();
			// let contoursMat = cv.Mat.zeros(srcMat.rows, srcMat.cols, cv.CV_8UC3);
			ImShow(srcMat);

			let grayMat = srcMat.clone();
			cv.cvtColor(srcMat, grayMat, cv.COLOR_RGBA2GRAY, 0);
			ImShow(grayMat);

			let threshMat = grayMat.clone();
			// cv.threshold(srcMat, srcMat, 128, 255, cv.THRESH_BINARY);
			cv.threshold(grayMat, threshMat, 125, 255, cv.THRESH_BINARY);
			ImShow(threshMat);

			let contours = new cv.MatVector();
			let hierarchy = new cv.Mat();
			// RETR_CCOMP
			// RETR_EXTERNAL
			// RETR_FLOODFILL
			// RETR_LIST
			// RETR_TREE
			// CHAIN_APPROX_NONE
			// CHAIN_APPROX_SIMPLE
			// CHAIN_APPROX_TC89_KCOS
			// CHAIN_APPROX_TC89_L1
			// cv.findContours(srcMat, contours, hierarchy, cv.RETR_CCOMP, cv.CHAIN_APPROX_NONE);
			cv.findContours(threshMat, contours, hierarchy, cv.RETR_CCOMP, cv.CHAIN_APPROX_NONE);
			// cv.findContours(srcMat, contours, hierarchy, cv.RETR_EXTERNAL, cv.CHAIN_APPROX_SIMPLE);
			// RETR_EXTERNAL 765, CHAIN_APPROX_SIMPLE.765, CHAIN_APPROX_TC89_KCOS.765, CHAIN_APPROX_TC89_L1.765
			// RETR_TREE 1173
			let counter = 0;
			let blackMat = new cv.Mat();
			for (let i = 0; i < contours.size(); ++i) {
				let cont = contours.get(i);

				let tmp = new cv.Mat();
				const arcLength = cv.arcLength(cont, true);
				cv.approxPolyDP(cont, tmp, 0.02 * arcLength, true);

				let area = cv.contourArea(cont, true);
				if (area < 1000 || arcLength < 650)
					continue;
				// console.log(arcLength)

				// cv.approxPolyDP(cont, tmp, 3, true);

				// if (tmp.data.length == 64)
				{
					counter++;
					// if (counter != 24)
					// 	continue;
					// console.log(tmp)
					// let color = new cv.Scalar(0, 0, 0, 255);
					let color = [255, 0, 0, 255];

					// cv.drawContours(contoursMat, contours, i, color, 0.5, cv.LINE_8, hierarchy, 100);
					cv.drawContours(contoursMat, contours, i, color, 2, cv.LINE_4, hierarchy);
					// LINE_4
					// LINE_8
					// LINE_AA
					// break;
				}
			}
			ImShow(contoursMat);

			window.scrollTo(0, document.body.scrollHeight);
		})();

		function ImShow(ImShow_img) {
			const newCanvasId = "img" + images.length;
			// show label
			const label = document.createElement("h2");
			label.innerHTML = newCanvasId;
			document.body.appendChild(label);
			// show canvas
			const newCanvas = document.createElement("canvas");
			newCanvas.setAttribute("id", newCanvasId);
			document.body.appendChild(newCanvas);
			cv.imshow(newCanvasId, ImShow_img);

			images.push("");
		}

		function createAndShowImageElement(base64 = "", labelText = "") {
			return new Promise((resolve, reject) => {
				const newImgElement = document.createElement("img");
				newImgElement.onload = function () {
					// show label
					const label = document.createElement("h2");
					label.innerHTML = !!labelText ? labelText : "img" + images.length;
					document.body.appendChild(label);

					// show image
					document.body.appendChild(newImgElement);
					images.push(base64);
					// return newImgElement
					resolve(newImgElement);
				}
				newImgElement.src = base64;
			});
		}
	</script>

</body>

</html>